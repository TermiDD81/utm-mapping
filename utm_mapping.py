# Паттерны для бесплатных поставщиков с их названиями
free_patterns = {
        "pp": "pp",
        "pesok": "pp",
        "ndzokt5": "pp",       
        "replay": "Replay",
        "replаy": "Replay",        
        "dubl": "Дубли",
        "dblvrn": "Двойная воронка",
        "otval": "Отвал",
        "mod": "pp",
        "dlsbp": "pp"
        }

# Список правил для определения поставщика
priority_rules = [
        ("dmp", "ДМП"),
        ("dmpone", "ДМП"),
        ("dmpnew", "ДМП"),       
        ("wr", "ВР"),
        ("rt", "Ростелеком"),
        ("t2", "Теле2"),
        ("lagom", "Игорь"),
        ("kokos", "Кокос"),
        ("vk", "ВКонтакте"),
        ("robot", "Robot_maks"),
        ("datacall", "Datacall"),
        ("alex", "Alex"),
        ("avito", "Avito"),
        ("reffection", "Рефекшн кинетик"),
        ("yandex", "Яндекс"),
        ("mk", "Яндекс"),
        ("spam", "Яндекс"),
        ("tg", "Telegram"),
        ("knowhow", "Ноухау"),
        ("khownow", "Ноухау"),
        ("voip", "gn_voip"),
        ("smstraf", "СМСтраф"),
        ("karl", "Карл"),
        ("andr", "Андрей"),
        ("botto", "Botto"),
        ("rasim", "Rasim"),
        ("scoring", "Скоринг"),
        ("bs", "Скоринг"),
        ("beeline", "Скоринг"),
        ("ipoteka", "Тест"),
    ]

# Паттерны для проектов
project_rules = [
    ('rf', 'Недвижимость (пр)'),
    ('бп', 'Недвижимость (бп)'),
    ('bp', 'Недвижимость (бп)'),
    ('perevod', 'Перевод звонка'),
    ('jk', 'ЖК'),
    ('avto', 'Авто'),
    ('bank', 'Банковские гарантии'),
    ('spectehnika', 'Спецтехника'),
    ('lising', 'Лизинг'),
    ('arenda', 'Аренда спецтехники'),
]

# Паттерны для направлений
project2_rules = [
    ('lidact', 'ЖК Лидактив'),
    ('zastr', 'ЖК Застройщики'),
    ('msk', 'Москва'),
    ('spb', 'Санкт-Петербург'),
    ('spb1', 'Санкт-Петербург'),
    ('krd', 'Краснодар'),
    ('rnd', 'Ростов'),    
    ('vld', 'Владивосток'),
    ('vladivostok', 'Владивосток'),    
    ('adygea', 'Адыгея'),
    ('arhangelsk', 'Архангельск'),
    ('arkhangelsk', 'Архангельск'),
    ('astrah', 'Астрахань'),
    ('bashkir', 'Уфа'),
    ('tatarstan', 'Уфа'),
    ('ufa', 'Уфа'),
    ('ekb', 'Екатеринбург'),    
    ('kazan', 'Казань'),
    ('kaliningrad', 'Калининград'),
    ('kaluga', 'Калуга'),
    ('krasnoyrsk', 'Красноярск'),
    ('krasnoyarsk', 'Красноярск'),
    ('crimea', 'Крым'),
    ('сrimea', 'Крым'),
    ('nn', 'Нижний Новгород'),
    ('novosib', 'Новосибирск'),
    ('novocib', 'Новосибирск'),
    ('perm', 'Пермь'),
    ('tula', 'Тула'),
    ('tyumen', 'Тюмень'),
    ('tumen', 'Тюмень'),
    ('udmurt', 'Удмуртия'),
    ('hmao', 'ХМАО'),
    ('khanty', 'ХМАО'),
    ('khabarovsk', 'Хабаровск'),
    ('cheliabinsk', 'Челябинск'),
    ('chel', 'Челябинск'),
    ('chelyabinsk', 'Челябинск'),
    ('yaroslavl', 'Ярославль'),
    ('izhevsk', 'Ижевск'),
    ('mytishchi', 'Мытищи'),
    ('narofominsk', 'Наро-Фоминск'),
    ('dubna', 'Дубна'),
    ('klin', 'Клин'),
    ('noginsk', 'Ногинск'),
    ('khotcovo', 'Хотьково'),
    ('vyborg', 'Выборг'),
    ('kirovsk', 'Кировск'),
    ('communar', 'Коммунар'),
    ('sochi', 'Сочи'),
]

jk_object = [
('centralnyi', 'Астрахань ЖК Центральный'),
('klub25', 'Санкт-Петербург ЖК Клуб 25'),
('pogoda', 'Пермь ЖК Погода'),
('ask', 'Краснодар АСК'),
('we', 'Пермь ЖК Мы '),
('belyaeva', 'Пермь ЖК Юг на Беляева'),
('sostoyanie', 'Ростов ЖК Состояние'),
('meridian', 'Тюмень ЖК Меридиан Слобода'),
('ecos', 'Санкт-Петербург ЖК Экос Кузмолово'),
('arhitektor', 'Владивосток ЖК Архитектор'),
('kashtan', 'Владивосток ЖК Каштановый двор'),
('futurist', 'Владивосток ЖК Футурист'),
('ozero', 'Краснодар ЖК Дом у озера'),
('plaza', 'Краснодар ЖК Плаза'),
('sport', 'Краснодар ЖК Спортивная деревня'),
('rodnoy', 'Краснодар ЖК Родной дом'),
('sobytiye', 'Ростов ЖК Событие'),
('grani', 'Краснодар ЖК Грани'),
('1799', 'Ростов ЖК 1799'),
('stolicyno', 'Ростов ЖК Сталицино'),
('serdtse2', 'Ростов Сердце Ростова 2'),
('october', 'Ростов ЖК Октябрь Парк'),
('nord', 'Ростов ЖК Норд'),
('levoberezhe', 'Ростов ЖК Левобережье'),
('legenda', 'Ростов ЖК Легенда Ростова'),
('gray', 'Ростов ЖК Gray'),
('frame', 'Ростов ЖК Frame'),
('dvizhenie61', 'Ростов ЖК Движение 61'),
('donskoy', 'Ростов ЖК Донской Арбат'),
('flora', 'Ростов ЖК Флора'),
('manhjetten', 'Ростов ЖК Манхэттен 2.0'),
('nasledie', 'Ростов ЖК Наследие'),
('persona', 'Ростов ЖК Персона'),
('zapadnye', 'Ростов ЖК Западные Аллеи'),
('tekuchev', 'Ростов ЖК Текучев'),
('reki', 'Ростов ЖК Город у реки'),
('botanika', 'Ростов ЖК Ботаника'),
('sosedi', 'Ростов ЖК Соседи'),
('pritjazhenie', 'Ростов ЖК Притяжение'),
('polet', 'Ростов ЖК Полет '),
('sokolniki', 'Ростов ЖК Сокольники'),
('siyanie', 'Ростов ЖК Сияние '),
('mechta', 'Ростов ЖК Мечта '),
('akademiya', 'Новосибирск ЖК Академия'),
('1956kvartaly', 'Новосибирск ЖК 1956. Кварталы Телецентра'),
('vesna', 'Новосибирск ЖК Весна'),
('vinograd', 'Новосибирск ЖК Виноград'),
('yasnyy', 'Новосибирск ЖК Город-парк Ясный берег'),
('divnogorskiy', 'Новосибирск ЖК Дивногорский'),
('ezhevika', 'Новосибирск ЖК Ежевика'),
('nikolskiy', 'Новосибирск ЖК Никольский Парк'),
('okolica', 'Новосибирск ЖК Околица'),
('spektr', 'Новосибирск ЖК Спектр'),
('stranaberegovaya', 'Новосибирск ЖК Страна. Береговая'),
('lermontovsky', 'Санкт-Петербург ЖК Лермонтовский 54'),
('promenade', 'Санкт-Петербург ЖК Promenade'),
('che', 'Санкт-Петербург ЖК Квартал Che'),
('novyylessner', 'Санкт-Петербург ЖК Новый Лесснер'),
('petrovskaya', 'Санкт-Петербург ЖК Петровская Доминанта'),
('domino', 'Санкт-Петербург ЖК Domino (Домино)'),
('glorax', 'Санкт-Петербург ЖК GloraX Балтийская (Глоракс Балтийская)'),
('view', 'Санкт-Петербург ЖК Grand View (Гранд Вью)'),
('moiseenko10', 'Санкт-Петербург ЖК Апартаменты Моисеенко 10'),
('vidi', 'Санкт-Петербург ЖК Инвест-отель VIDI (ВИДИ)'),
('institutskiy', 'Санкт-Петербург ЖК Институтский'),
('lisichanskaya22', 'Санкт-Петербург ЖК Лисичанская'),
('bolshaya', 'Санкт-Петербург ЖК ЛСР. Большая Охта'),
('sampsonievskiy', 'Санкт-Петербург ЖК Сампсониевский 32'),
('korona', 'Санкт-Петербург ЖК Северная Корона'),
('talento', 'Санкт-Петербург ЖК Клубный дом TALENTO'),
('manhattan', 'Санкт-Петербург ЖК Клубный дом Манхэттен'),
('pobedy', 'Санкт-Петербург ЖК Парк Победы'),
('modum', 'Санкт-Петербург ЖК Модум'),
('neve', 'Санкт-Петербург ЖК Эталон на Неве'),
('bolshoj67', 'Санкт-Петербург ЖК Большой 67'),
('morskaya', 'Санкт-Петербург ЖК Морская набережная'),
('1733', 'Санкт-Петербург ЖК 17.33'),
('regenbogen', 'Санкт-Петербург ЖК Регенбоген'),
('akvilonzalive', 'Санкт-Петербург ЖК Аквилон ZALIVE'),
('avant', 'Санкт-Петербург ЖК Avant'),
('belyi', 'Санкт-Петербург ЖК Белый Остров'),
('karetnogo', 'Санкт-Петербург ЖК Дом на Васильевском'),
('amo', 'Санкт-Петербург ЖК Amo'),
('leaves', 'Санкт-Петербург ЖК Аквилон Leaves'),
('respect', 'Санкт-Петербург ЖК Respect'),
('bairon', 'Санкт-Петербург ЖК Байрон'),
('peremen', 'Санкт-Петербург ЖК Ветер перемен 2'),
('alpen', 'Санкт-Петербург ЖК ALPEN'),
('friends', 'Санкт-Петербург ЖК Friends'),
('kudrovo2', 'Санкт-Петербург ЖК ID Kudrovo II'),
('moskovskiy', 'Санкт-Петербург ЖК ID Moskovskiy'),
('newpiter', 'Санкт-Петербург ЖК NewПитер'),
('kapralskiy', 'Санкт-Петербург ЖК Капральский'),
('lyubograd', 'Санкт-Петербург ЖК Любоград'),
('murino', 'Санкт-Петербург ЖК Мурино Клаб'),
('gorelovo', 'Санкт-Петербург ЖК Новое Горелово'),
('yanila', 'Санкт-Петербург ЖК Янила Драйв'),
('yaninskiy', 'Санкт-Петербург ЖК Янинский лес'),
('lesart2', 'Санкт-Петербург ЖК ЛесART'),
('kantemirovskaya11', 'Санкт-Петербург ЖК Кантемировская'),
('chernaya', 'Санкт-Петербург ЖК Zoom Черная речка'),
('chkalov', 'Санкт-Петербург ЖК Чкалов'),
('FoRestakvilon', 'Санкт-Петербург ЖК FoRest Аквилон'),
('novoorlovsky', 'Санкт-Петербург ЖК Квартал Новоорловский'),
('lubograd', 'Санкт-Петербург ЖК Любоград'),
('milya', 'Санкт-Петербург ЖК Морская миля'),
('novoesertolovo', 'Санкт-Петербург ЖК Микрорайон Новое Сертолово'),
('parkolovo', 'Санкт-Петербург ЖК Парголово'),
('strizhy', 'Санкт-Петербург ЖК Стрижи в Невском'),
('univer', 'Санкт-Петербург ЖК Универ Сити'),
('yasno', 'Санкт-Петербург ЖК Ясно.Янино'),
('yugtaun', 'Санкт-Петербург ЖК ЮгТаун. Олимпийские кварталы'),
('zeleny', 'Санкт-Петербург ЖК Зелёный квартал'),
('prinevsky', 'Санкт-Петербург ЖК Приневский'),
('river', 'Москва ЖК River Park Towers Кутузовский'),
('primavera', 'Москва ЖК Клубный город на реке Primavera'),
('luzhniki', 'Москва ЖК Luzhniki Collection'),
('avtory', 'Москва ЖК Лаунж-дома Авторы на Большой'),
('businovskiy', 'Москва ЖК Бусиновский парк'),
('moskvoreche', 'Москва ЖК Москворечье'),
('republic', 'Москва ЖК Republic'),
('lavrushinskiy', 'Москва ЖК Дом Лаврушинский'),
('slava', 'Москва ЖК SLAVA'),
('pride', 'Москва ЖК Pride'),
('hide', 'Москва ЖК HIDE'),
('zilart', 'Москва ЖК Зиларт'),
('badaevsky', 'Москва ЖК Бадаевский'),
('frunzenskaya', 'Москва ЖК Фрунзенская 30'),
('life', 'Москва ЖК LIFE TIME'),
('chainye', 'Сочи ЖК Чайные холмы'),
('alpika', 'Сочи ЖК Новая Альпика'),
('portugalii', 'Сочи ЖК Каравелла Португалии'),
('gorniy', 'Сочи ЖК Горный Квартал'),
('letniy', 'Сочи ЖК Летний'),
('svetsky', 'Сочи ЖК Светский лес'),
('olivia', 'Сочи ЖК Olivia'),
('frukty', 'Сочи ЖК Фрукты'),
('lestorya', 'Сочи ЖК Лестория'),
('vremya', 'Тула ЖК Время'),
('segodnya', 'Тула ЖК Сегодня'),
('pryanichnaya', 'Тула ЖК Пряничная Слобода'),
('suvorovskiy', 'Тула ЖК Суворовский'),
('kulik', 'Тула ЖК Кулик'),
('tula', 'Тула ЖК Новая Тула'),
('karpova', 'Тула ЖК Карпова'),
('nadezhnyy', 'Тула ЖК Надежный'),
('platon', 'Тула ЖК Платон парк'),
('ritmy', 'Тюмень ЖК Ритмы'),
]

def determine_supplier(parts):
    """
    Обрабатывает фрагменты метки, сначала проверяя на бесплатного поставщика в конце метки. Если находится бесплатный поставщик, функция завершается.
    Если метка не от бесплатного поставщика, то определяется платный. Поставщик назначается по первому фрагменту, который соответствует признаку 
    """
    # Проверяем, есть ли последний элемент в списке бесплатных поставщиков
    last_part = parts[-1] if parts else ""
    if last_part in free_patterns:
        return free_patterns[last_part]

    # Словарь для хранения позиций найденных паттернов
    matches = {}

    # Перебираем элементы метки и ищем точные совпадения
    for i, part in enumerate(parts):
        for pattern, supplier in priority_rules:
            if part == pattern:  # Строгое соответствие
                # Если совпадение уже найдено, берем более раннюю позицию
                if supplier not in matches or matches[supplier] > i:
                    matches[supplier] = i

    # Если есть совпадения, возвращаем поставщика с минимальной позицией
    if matches:
        return min(matches, key=matches.get)

    # Если совпадений нет
    return "Неизвестно"

def determine_supplier2(supplier, parts):
    """
    Определяет стоимость покупки на основе поставщика и фрагментов метки.
    """
    # Приводим фрагменты к единому формату: заменяем , -> . и русскую р -> латинскую p
    normalized_parts = [p.replace(',', '.').replace('р', 'p') for p in parts]

    zero_price = {'0p', 'free'}

    # Словарь с правилами
    rules = {
        'Андрей': {'7p': 'andr_7p', '5p': 'andr_5p', **{k: 'andr_0p' for k in zero_price}},
        'Теле2': {'4.5p': 't2_4.5p'},
        'ВР': {'cod': 'wr_cod', 'meg': 'wr_meg'},
        'Datacall': {'10p': 'datacall_10p', '7.5p': 'datacall_7.5p', '6p': 'datacall_6p',
                     '5p': 'datacall_5p', '3p': 'datacall_3p', **{k: 'datacall_0p' for k in zero_price}},
        'Ноухау': {k: 'knowhow_0p' for k in zero_price},
        'ДМП': {'cod': 'dmp_cod'},
        'Рефекшн кинетик': {'cod': 'reffection_cod', '3.5p': 'reffection_3,5p', **{k: 'reffection_0p' for k in zero_price}},
        'Игорь': {'6p': 'lagom_6p', '12p': 'lagom_12p', '10p': 'lagom_10p', **{k: 'lagom_0p' for k in zero_price}},
        'Скоринг': {k: 'beeline_scoring_0p' for k in zero_price}
    }

    # Значения по умолчанию для поставщиков
    default_supplier = {
        'ВР': 'wr',
        'ДМП': 'dmp',
        'Скоринг': 'beeline scoring',
        'Теле2': 't2',
        'Рефекшн кинетик': 'reffection',
        'Ноухау': 'knowhow',
        'Кокос': 'kokos',
        'Ростелеком': 'RT ростелеком'
    }

    # Получаем правила для текущего поставщика
    supplier_rules = rules.get(supplier, {})

    # Словарь для хранения позиций найденных паттернов
    matches = {}

    # Перебираем элементы метки и ищем точные совпадения с паттернами поставщика
    for i, part in enumerate(normalized_parts):
        for pattern, supplier_pattern in supplier_rules.items():
            if part == pattern:  # Строгое соответствие
                # Если совпадение уже найдено, берем более раннюю позицию
                if supplier_pattern not in matches or matches[supplier_pattern] > i:
                    matches[supplier_pattern] = i

    # Если есть совпадения, возвращаем поставщика с минимальной позицией
    if matches:
        return min(matches, key=matches.get)

    # Если ничего не нашли, возвращаем дефолтное значение
    return default_supplier.get(supplier, 'pp')
    
def determine_project(parts):
    """
    Обрабатывает фрагменты метки, сначала проверяя на бесплатного поставщика 'pp'в конце метки. Если находится бесплатный поставщик, метка читается с права на лево.
    Проект назначается по первому фрагменту, который соответствует признаку
    """
    if 'pp' in parts[-2:]:
        parts.reverse()
    
    # Словарь для хранения позиций найденных паттернов
    matches = {}

    # Перебираем элементы метки и ищем точные совпадения
    for i, part in enumerate(parts):
        for pattern, project in project_rules:
            if part == pattern:  # Строгое соответствие
                # Если совпадение уже найдено, берем более раннюю позицию
                if project not in matches or matches[project] > i:
                    matches[project] = i

    # Если есть совпадения, возвращаем проект с минимальной позицией
    if matches:
        return min(matches, key=matches.get)

    # Если совпадений нет
    return "Неизвестно"

def determine_project2(project, parts):
    """
    Обрабатывает фрагменты метки, сначала проверяя на бесплатного поставщика 'pp' в конце метки. Если находится бесплатный поставщик, метка читается с права на лево.
    Направление назначается по первому фрагменту, который соответствует признаку и корректируется в зависимости от проекта.
    """
    if 'pp' in parts[-2:]:
        parts.reverse()

    if project in {'Банковские гарантии', 'Спецтехника', 'Лизинг', 'Аренда спецтехники'}:
        project2 = project
        return project2
    
    if project == 'ЖК':
        parts = [p for p in parts if p != 'vld']
    else:
        parts = [p for p in parts if p != 'zastr']

    # Словарь для хранения позиций найденных паттернов
    matches = {}

    # Перебираем элементы метки и ищем точные совпадения
    for i, part in enumerate(parts):
        for pattern, project2 in project2_rules:
            if part == pattern:  # Строгое соответствие
                # Если совпадение уже найдено, берем более раннюю позицию
                if project2 not in matches or matches[project2] > i:
                    matches[project2] = i

    # Если есть совпадения, возвращаем направление с минимальной позицией
    if matches:
        project2 = min(matches, key=matches.get)
        # Проверяем проект и корректируем направление
        if project2 == 'ЖК Застройщики' and 'test' in parts:
            project2 = 'ЖК Застройщики тест'

        elif project == 'ЖК' and project2 in {'Ростов', 'Новосибирск', 'Сочи', 'Тула', 'Санкт-Петербург', 'Москва'}:
            project2 = project + ' ' + project2

        elif project == 'Недвижимость (бп)' and project2 in {'Краснодар','Владивосток','Санкт-Петербург'}:
            project2 = project2 + ' (без прозвон)'

        elif project == 'Перевод звонка' and project2 in {'Мытищи', 'Санкт-Петербург', 'Москва'}:
            project2 = project2 + ' (звонок)'

        elif project == 'Перевод звонка' and project2 in {'Уфа', 'Калининград', 'Краснодар', 'Красноярск', 'Крым', 'Тюмень',
                                                          'Нижний Новгород', 'Новосибирск', 'Екатеринбург', 'Ростов', 'Казань'}:
            project2 = 'Перевод КЦ Регионы'

        elif project == 'Перевод звонка' and project2 in {'Ногинск', 'Клин', 'Хотьково', 'Дубна', 'Наро-Фоминск'}:
            project2 = 'Перевод КЦ ДМО'

        elif project == 'Перевод звонка' and project2 in {'Выборг', 'Кировск', 'Коммунар'}:
            project2 = 'Перевод КЦ ДЛО'

        elif project == 'Недвижимость (пр)' and project2 in {'Екатеринбург', 'Казань', 'Новосибирск', 'Ростов', 'Тюмень'}:
            project2 = 'Яндекс Т1'

        elif project == 'Недвижимость (пр)' and project2 in {'Ярославь', 'ХМАО', 'Нижний Новгород', 'Калининград', 'Калуга', 'Уфа', 'Красноярск', 'Челябинск',
                                                             'Тула', 'Ижевск', 'Пермь', 'Хабаровск', 'Архангельск', 'Адыгея', 'Крым', 'Ярославль'}:
            project2 = 'Яндекс Т2'          

        elif project == 'Авто' and project2 in {'Екатеринбург', 'Челябинск'}:
            project2 = 'Авто Екб и Члб'  

        elif project == 'Авто' and project2 not in {'Екатеринбург', 'Челябинск'}:
            project2 = 'Авто Мск и Спб'      
        
    else:
        if project == 'Авто': #Старые метки Авто не имели приписки 'spb' или 'msk', но относились туда
            project2 = 'Авто Мск и Спб' 
            return project2
        
        return project  # Если совпадений нет, возвращаем название проекта

    return project2  # Возвращаем итоговое значение

def determine_city(project, project2, parts):
    """
    Обрабатывает фрагменты метки, сначала проверяя на бесплатного поставщика '_pp'в конце метки. Если находится бесплатный поставщик, метка читается с права на лево.
    Город назначается по первому фрагменту, который соответствует признаку и корректируется в зависимости от проекта.
    Объекты ЖК определяются по отдельному списку.
    """
    if 'pp' in parts[-2:]:
        parts.reverse()

    if project in {'Банковские гарантии', 'Спецтехника', 'Лизинг', 'Аренда спецтехники', 'Авто'}:
        return project2
    
    if project == 'ЖК':
        parts = [p for p in parts if p != 'vld']
    else:
        parts = [p for p in parts if p != 'zastr']
         
    # Проверяем на объекты ЖК
    if project == 'ЖК':
        for part in parts:
            for pattern, city_object in jk_object:
                if part == pattern:
                    return city_object
                
    # Словарь для хранения позиций найденных паттернов
    matches = {}

    # Перебираем элементы метки и ищем точные совпадения
    for i, part in enumerate(parts):
        for pattern, city in project2_rules:
            if part == pattern:  # Строгое соответствие
                # Если совпадение уже найдено, берем более раннюю позицию
                if city not in matches or matches[city] > i:
                    matches[city] = i

    # Если есть совпадения, возвращаем направление с минимальной позицией
    if matches:
        city = min(matches, key=matches.get)
        # Проверяем проект и корректируем направление
        if project == 'Перевод звонка':
            city += ' (звонок)'  
        elif project == 'Недвижимость (бп)':
            city += ' (без прозвон)'   

        return city  # Возвращаем итоговое значение
    
    return project2

def determine_department(parts):

    if 'traf' in parts:
        return 'Реклама'
    else:
        return 'Базы'